# 分析ログ：残存テスト失敗の根本原因特定

## 1. 目的

`balanceAndChange.test.ts`のパス後も失敗し続ける`plOnlyAst.test.ts`と`fam.behavior.test.ts`の根本原因を、ユーザー提示の思考フローに立ち返って正確に特定する。

## 2. `plOnlyAst.test.ts` の失敗分析

- **現象:** 2年目の現金残高の期待値が合わない (`Expected: 970`, `Received: 50`)。

- **原因特定（思考フローによる再計算）:**
  1.  **前提の確認:** テストの`PREVS`で、**期首の現金残高は`50`**と定義されている。
  2.  **1年目の計算:**
      - 純利益は`455`。
      - 運転資本の変動はないため、`CFO = 455`。
      - 思考フローに基づき、`1年目末現金 = 期首現金(50) + CFO(455) = 505` となるべき。
      - しかし、テスト内の期待値`EXPECTS[0].CASH_END`は`455`となっており、**期首現金を`0`と仮定した計算結果**になっている。これが第一の矛盾。
  3.  **2年目の計算:**
      - 純利益は`515`。
      - 運転資本の変動はないため、`CFO = 515`。
      - 思考フローに基づき、`2年目末現金 = 1年目末現金(505) + CFO(515) = 1020` となるべき。
      - テスト内の期待値`EXPECTS[1].CASH_END`は`970`となっており、これも計算が合わない。

- **結論:** `plOnlyAst.test.ts`の失敗は、CF計算ロジックのバグではなく、**テストデータ(`EXPECTS`)自体が、現在のCFベースの正しい計算ロジックと整合していない**ことが原因である。

## 3. `fam.behavior.test.ts` の失敗分析

- **現象:** `cash prev missing`（前期の現金実績がない）テストで、`rowIndexById`が`-1`を返し、勘定が見つからないエラーとなる。

- **原因特定（コード実行フローの追跡）:**
  1.  このテストは、現金を含まない実績データ (`prevsNoCash`) を`importActuals`に渡している。
  2.  `importActuals`は、実績データに含まれる勘定科目のみを、表示順リスト (`this.orderAccountIds`) に登録する。
  3.  `compute`メソッドは、前期実績がなくても内部的に現金勘定を計算し、`table`（計算結果のGrid）には正しい現金の値を保持している。
  4.  しかし、テストは最後に`getTable({ fs: 'BS' })`を呼び出す。
  5.  `getTable`メソッドは、`this.orderAccountIds`を元に行を生成するため、このリストに存在しない現金勘定（`cash_jp`）は、最初から行の候補に含まれない。
  6.  結果として、`getTable`が返す`rows`配列に`cash_jp`が含まれず、`rowIndexById`が`-1`を返してエラーとなる。

- **結論:** `fam.behavior.test.ts`の失敗は、**`compute`の過程で動的に生成された勘定（この場合は現金）が表示順リスト`orderAccountIds`に追加されないまま、`getTable`が呼び出されている**ことが原因である。

## 4. 最終修正方針

- **`plOnlyAst.test.ts`:** CF計算ロジックに沿って手計算した、正しい現金の期待値 (`505`と`1020`) に`EXPECTS`を修正する。
- **`fam.ts`:** `compute`メソッドのロジックを修正し、計算過程で新たに追加された勘定（特に現金）を、`this.orderAccountIds`に登録する処理を追加する。これにより`getTable`が正しく現金の行を返せるようにする。
