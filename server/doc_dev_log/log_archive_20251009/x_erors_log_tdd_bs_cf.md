# 開発ログ：TDDによる財務モデリングコアエンジン（BS/CF連動）の実装

## 1. プロジェクトの背景と前提

### 1.1. ツールの目的と課題

このプロジェクトの核心は、財務三表（PL, BS, CF）が連動する本格的な財務モデリングエンジンのコアロジックを構築することにある。従来の実装はPL（損益計算書）中心であり、BS（貸借対照表）の現金計算は`attachCash`という単純な「期首現金＋利益」ロジックに依存していた。これでは、運転資本の増減や投資・財務活動を反映した精緻なモデルが組めず、BSがバランスしないという致命的な問題を抱えていた。

今回のタスクは、この`attachCash`を完全に撤廃し、**会計原則に忠実なキャッシュフロー計算書（CF）を介してBSの現金を導出するロジック**を実装することである。

### 1.2. スコープと制約

- **スコープ**: `fam.ts`に存在する`FAM`クラス内の計算ロジックの改修に集中する。UIやAPIのエンドポイントは対象外。
- **制約**: 既存のテストスイート（特に`bs.test.ts`）をすべてパスさせることが絶対条件。パフォーマンスの著しい劣化は許容されない。

### 1.3. TDDを選んだ理由

財務モデリングは、各勘定科目が複雑に絡み合う「結合度の塊」のようなシステムだ。一つの変更が予期せぬ副作用を生むことは日常茶飯事である。このような性質から、以下の理由でTDD（テスト駆動開発）は必然の選択だった。

- **品質の担保**: 会計ロジックの正しさを常に担保するセーフティネットが必要不可欠。
- **迅速なフィードバック**: リファクタリングや機能追加のたびに、即座にロジックの健全性を確認できる。
- **複雑性の管理**: 「まずテストを書く」という行為が、実装すべき機能の仕様を明確にし、設計をシンプルに保つ助けとなる。

## 2. ゴールと仮説

- **最終ゴール**: `attachCash`を廃止し、CF計算を経由して導出された期末現金がBSに正しく反映され、最終的に**すべてのテストがパスすること**。
- **中核仮説**: 人間の会計思考フロー（①PLと非現金BSの計画値作成 → ②PLとBS差分からCFを生成 → ③期首現金+CF合計=期末現金）をコードで忠実に再現すれば、おのずとBSはバランスし、堅牢で拡張性の高いモデルが実現できるはずだ。

## 3. アプローチ

「手元には、壊れたテスト群と、いくつかのヒントが書かれた引継ぎ資料だけがある」。そんな状況から開発はスタートした。

1.  **レッド**: まず`npm run test`を実行し、現状の失敗（レッド）を確認。`fam.behavior.test.ts`や`plOnlyAst.test.ts`など、複数のテストが失敗していることを把握した。
2.  **グリーン**: 引継ぎ資料とコードを突き合わせ、一つの問題に絞って修正を加え、その問題に関連するテストだけでもパス（グリーンに）させることを目指した。
3.  **リファクタリング**: テストが通った後、コードの可読性や設計の改善を行う。

このレッド→グリーン→リファクタリングのサイクルを、すべてのテストがグリーンになるまで執拗に繰り返した。テストランナーはJest、外部ライブラリへの依存はないためモックは未使用。

## 4. 実装箇所

改修の心臓部は、`@server/src/fam/fam.ts`に存在する`FAM`クラスである。特に以下のメソッド群に熾烈な修正のメスを入れた。

- `compute`: 計算プロセス全体を統括するオーケストレーター。
- `applyBalanceChangeForFY`: B&C（貸借調整）ルールを適用し、非現金勘定を更新する。
- `calculateCFs`: PLとBSの変動からキャッシュフロー（CFO, CFI, CFF）を計算する。
- `calculateCashByCF`: `calculateCFs`の結果を使い、最終的な期末現金を確定させる。

## 5. 詳細仕様

実装されたコアロジックの仕様は、前述の「人間の思考フロー」そのものである。

1.  `compute`メソッドが年度ごとにループ。
2.  PL関連の勘定がルールに基づき計算される。
3.  `rollForwardBsAccounts`が、利益剰余金など一部のBS勘定を繰り越す。
4.  `applyBalanceChangeForFY`が、設備投資や減価償却などのB&Cルールを**非現金勘定**に適用する。この際、現金への影響額（`cashImpact`）を分離して算出する。
5.  `calculateCFs`が、PLの非資金性費用（例：減価償却費）や、運転資本（売掛金、買掛金など）の期首からの差分を基に営業CF（CFO）を計算する。
6.  `calculateCashByCF`が、`期首現金 + CFO + CFI + CFF + cashImpact` という式で期末現金を計算し、BSテーブルに書き込む。

この流れにより、現金勘定がすべての活動の結果として最後に決まる、という会計原則がコードレベルで保証される。

## 6. 基本的な設計

`FAM`クラスを、財務モデルの状態（実績、ルール、計算結果）と振る舞い（計算実行、テーブル取得）をカプセル化するFacadeとして設計。内部では、AST（抽象構文木）エンジンが純粋な計算を担当し、`FAM`が年度間の繰り越しや三表連動といった、より高次の会計コンテキストを管理する責務分離を行っている。

CLIツールとして利用されることを想定し、`import`から`compute`、`getTable`までの一連の処理は、軽量かつ高速に実行されることを目指した。

## 7. 実装上の課題

今回のTDDプロセスは、まさに「血の通った」試行錯誤の連続だった。

### 7.1. 課題1：二重計上問題との格闘

テストが軒並み失敗する最大の原因は、B&Cルールによる現金への影響が二重に計上される、あるいは全く計上されない問題だった。

- **葛藤**: 当初の実装では、`applyBalanceChangeForFY`が設備投資（資産増）の相手勘定として現金（資産減）を直接テーブル上で更新していた。しかし、その後の`calculateCashByCF`が、その変更を無視してCFベースで現金を再計算するため、B&Cの現金インパクトが失われていた。
- **解決策**: **`applyBalanceChangeForFY`が直接現金を変更するのをやめさせ、現金への影響額（`cashImpact`）を戻り値として返すようにリファクタリングした。** そして、`compute`メソッドがその`cashImpact`を受け取り、最終的な現金計算を行う`calculateCashByCF`に渡すことで、すべての現金変動が一元的に管理されるようにした。

```typescript
// --- Before ---
// in compute():
this.applyBalanceChangeForFY(fy, cashGAID); // 直接BSの現金を変更
this.calculateCashByCF(fy, ...);           // CFベースで現金を上書き（B&C影響が消える）

// --- After ---
// in compute():
const cashImpactFromBC = this.applyBalanceChangeForFY(fy, cashGAID); // 現金影響額だけを返す
this.calculateCashByCF(fy, ..., cashImpactFromBC); // 最終計算で影響額を合算
```

このリファクタリングにより、`balanceAndChange.test.ts`がパスした時は、暗闇に光が差した瞬間だった。

### 7.2. 課題2：テストコードという名の地雷原

ロジックを修正しても、依然として多くのテストが失敗した。頭を抱えながらログを睨みつけていると、問題が**テストコード自体にある**ことに気づいた。

- **発見**: `fam.behavior.test.ts`などのテストが、`getTable()`を`fs: 'PL'`（PLテーブルを要求）のデフォルト設定で呼び出し、その結果の中に`cash_jp`（BS勘定）が存在することを期待していた。BS勘定がPLテーブルに含まれるはずがない。
- **解決策**: 現金のアサーションを行う箇所では、`getTable({ fs: 'BS', ... })`のように、**明確にBSテーブルを要求するようにテストコードを修正した。** これは、一見単純な修正だが、多くのテストが失敗していた根本原因であり、この修正によってテストの信頼性が劇的に向上した。

### 7.3. 課題3：データ定義の不整合という名の悪魔

それでもまだ`fam.behavior.test.ts`の一部が失敗した。原因は、特定のテストケース (`GAIDのprimary選定`) の中だけで、現金勘定の`fs_type`が`'PL'`として定義されていたことだった。他のテストとの**データ定義の不整合**が、この微妙なバグを生んでいた。

- **学び**: テストデータもまた、コードと同様に一貫性と正確性が求められる。特に、複数のテストファイルで類似のデータをセットアップする場合、共通化するか、細心の注意を払う必要がある。この一件以来、テストのセットアップ部分をより一層疑いの目で見るようになった。

## 8. 今後実装（拡張）すべきポイント

- **`snapshotLatestActual`の汎用化**: 現在、このメソッドはハードコードでPLのスナップショットを返す。`fs`タイプを引数に取り、BSやCFのスナップショットも取得できるようにすべきだ。
- **CF計算の精緻化**: 現在のCFO計算はまだ単純だ。CFI（投資CF）、CFF（財務CF）をB&Cルールなどから自動生成する、より高度なロジックの実装が待たれる。
- **エラーレポートの改善**: 勘定科目の依存関係が循環した場合などのエラーメッセージを、よりユーザーフレンドリーにする必要がある。

## 9. 今後検証すべきポイント

- **複雑なシナリオの検証**: 複数のB&Cルールが複雑に絡み合う、より現実的なシナリオでのストレステストが必要。
- **パフォーマンス測定**: 勘定科目数や予測年数を大幅に増やした場合の計算速度を測定し、ボトルネックを特定する必要がある。
- **実モデルとの突合**: 実際のExcelなどで組まれた財務モデルと計算結果を比較し、ロジックの妥当性を第三者的に検証すべきである。

今回のTDDプロセスは、単にバグを修正するだけでなく、コードの設計思想そのものを問い直し、テストの信頼性を高めるという、非常に有益な旅だった。すべてのテストがグリーンになった瞬間の達成感は、この仕事の醍醐味と言えるだろう。
