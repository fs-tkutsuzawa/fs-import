# 統合テストスイート（`@server/test`）に関する詳細分析レポート

**日付**: 2025年10月9日
**目的**: `@server/test`配下に存在するテスト群の目的、機能、および歴史的経緯を解明する。さらに、一部テストが失敗する根本原因を特定し、デバッグのスペシャリストとして、その修正方針までを具体的に提示する。

---

### 1. テストスイートの目的と歴史的経緯の推論

`@server/test`配下のテスト群は、`@server/src/tests`に存在する**コア計算エンジン（`FAM`）の単体・結合テスト**とは、その目的と性質を明確に異にする。

- **`@server/src/tests`**:
  - **目的**: コアロジックの**会計的・数学的正当性**を、メモリ上で完結する形で検証する。
  - **性質**: ホワイトボックステスト。`FAM`クラスの内部メソッドやデータ構造を直接操作し、計算過程の正しさをアサートする。

- **`@server/test`**:
  - **目的**: **UIから入力されたデータが、APIを経由してDBに正しく永続化され、再度API経由で取得できるか**という、一連のデータフローを検証する。これは、コアロジックが実装される以前、あるいはそれと並行して、UI-API-DB間の連携を確立するために作られた**E2E（エンドツーエンド）テスト**である。
  - **性質**: ブラックボックステスト。HTTPリクエストを実際に発行し、DBの状態を直接確認することで、システムの外部的な振る舞いを検証する。

**歴史的経緯の推論**:
Gitの履歴やドキュメントから、このテスト群は、UI開発者が計算ルール設定画面（`FinancialModelSetupPage.tsx`）を実装するにあたり、バックエンドAPIのモックとして、あるいはAPIの基本仕様を定義するために先行して作成されたものと推測される。`test-all-parameters-no-delete.ts`のように、様々なパラメータタイプを網羅的にDBに保存しようと試みている点は、その証左と言える。

### 2. 主要テストの機能分析

- **`setup-*.ts`**: テストの前提となるマスターデータ（企業、ユーザー、シナリオ、勘定科目）をDBに投入する。CI/CD環境や新規開発環境のセットアップを自動化する目的を持つ。
- **`test-calculation-rules-api.ts` / `full-integration-test.ts`**: 計算ルールAPI（`/api/calculation-rules`）のCRUD（作成、読み取り、更新、削除）操作が、HTTPリクエストを通じて正しく実行され、DBに反映されるかをテストする。
- **`test-all-parameters-no-delete.ts`**: UI上で設定可能な**すべての計算ルールパターン**を、API経由でDBに保存できるかを確認するストレステスト。`delete`を含まないのは、テスト実行後にDBの状態を目視で確認することを意図しているためと考えられる。
- **`check-*.ts` / `verify-*.ts`**: DBスキーマやデータの整合性を直接クエリして確認するための、補助的なユーティリティスクリプト。

### 3. テスト失敗の根本原因分析

現在、これらのテストの一部、特に`test-all-parameters-no-delete.ts`や`full-integration-test.ts`が失敗しています。その根本原因は、**UI/API側の仕様と、DBスキーマの間に生じた「歴史的な不整合」**にあります。

#### 根本原因：`rule_definition`のJSONB構造の不一致

- **テスト側の期待**:
  - `test-all-parameters-no-delete.ts`を見ると、`growth_rate`ルールを保存する際に、APIに`{ "rate": 5 }`という`config`オブジェクトを送信しています。
  - これは、UI側が当初、計算ルールの設定値をフラットなキーと値のペアでAPIに渡すことを想定していた名残です。

- **API/DB側の現状**:
  - しかし、その後のDB設計の進化（`20251006_DDL.sql`など）により、`calculation_rules`テーブルの`rule_definition`カラム（JSONB型）は、**コアエンジン（`FAM`）が要求する`RuleInput`型に近い、より構造化されたJSON**を格納するように変更されています。
  - 例えば、`growth_rate`の場合、DBは`{ "type": "GROWTH_RATE", "value": 0.05, "refs": [...] }`のような構造を期待します。

- **結論**:
  - テストスクリプトが送信している**古い形式の`config`オブジェクト**と、現在のAPIがDBに保存しようとする際に期待している**新しい`rule_definition`のJSON構造**との間に、深刻なミスマッチが生じています。
  - APIサーバーは、古い形式の`config`を新しい`rule_definition`に正しく変換できず、結果としてDBへの`INSERT`または`UPDATE`でエラーが発生し、テストが失敗しています。`custom_calc`や`prev_end_plus_change`など、他の多くのパラメータタイプでも同様の問題が発生していると断定できます。

### 4. デバッグと修正方針（コンプリートワーク）

この問題を解決し、テストスイートを正常化するため、以下の段階的な修正を提案します。

1.  **APIの防御力強化**:
    - **箇所**: `/api/calculation-rules`の`POST`および`PUT`ハンドラ。
    - **修正**: APIは、UIから送られてくる`config`オブジェクトを**信頼せず**、必ずサーバーサイドで厳密なバリデーションと、DBが期待する`rule_definition` JSON構造への**変換処理**を行う責務を負うべきです。
    - **具体例**:

      ```typescript
      // In API handler for calculation rules
      const { type, config } = await c.req.json();
      let ruleDefinition;

      if (type === 'growth_rate') {
        if (typeof config.rate !== 'number') {
          return c.json({ error: 'Invalid config for growth_rate' }, 400);
        }
        // DB/Engineが期待する構造に変換
        ruleDefinition = {
          type: 'GROWTH_RATE',
          value: config.rate / 100, // パーセントを小数に変換
          refs: [
            /* ... build refs ... */
          ], // 参照情報も構築
        };
      } else if (type === 'ratio') {
        // ...同様に他のタイプも変換...
      }
      // ... DBに ruleDefinition を保存 ...
      ```

2.  **テストコードの近代化**:
    - **箇所**: `test-all-parameters-no-delete.ts`, `full-integration-test.ts`など。
    - **修正**: APIを修正するだけでなく、テストコード自体も現在のAPI仕様に合わせて更新します。テストが送信する`config`オブジェクトを、現在のUIコンポーネントが実際に送信するであろう、より現実に即した形式に修正します。これにより、テストが「生きたドキュメント」としての価値を取り戻します。

3.  **セットアップスクリプトの拡充**:
    - **箇所**: `setup-test-accounts.ts`
    - **修正**: 現在、テストアカウントはPL科目が中心です。`prev_end_plus_change`のようなBS科目向けのルールをテストするためには、`現金`、`売掛金`、`有形固定資産`といったBS勘定を、テストデータとして予め作成しておく必要があります。このセットアップを拡充し、テストの前提条件を安定させます。

### 5. 総括

`@server/test`配下のテスト群は、プロジェクト初期におけるUI-API-DB間の連携を確立するための重要な役割を担ってきました。しかし、その後のDBスキーマとコアロジックの進化に追随できず、現在その役割を果たせていません。

テストの失敗は、**API層における「UIからの入力の信頼」と「データ変換ロジックの欠如」**という、アーキテクチャ上の弱点を浮き彫りにしています。

上記修正方針に基づき、APIに堅牢な変換・検証ロジックを実装し、テストコードを近代化することで、このテストスイートは再びプロジェクト全体の品質を保証する強力なツールとして復活するでしょう。
