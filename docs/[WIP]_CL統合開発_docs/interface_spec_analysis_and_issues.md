# インターフェース仕様の妥当性検証と論点抽出

**日付**: 2025年10月8日
**目的**: 提案されたUI向けインターフェース仕様が、データフロー全体（DB → コアロジック → UI）において、実装上の重要な考慮点（勘所）をすべて捉えられているか、クリティカルな視点で検証し、明確化すべき論点を抽出する。

---

### 総括評価

提案された仕様書およびJSONスキーマは、「関心の分離」の原則に基づき、各コンポーネント（UI, API, コアロジック）の責務を明確に分離しており、非常に堅牢な設計である。特に、計算エンジンは純粋な数値計算に集中し、UI向けのデータ整形はAPI層が担うという方針は、システム全体の保守性と拡張性を高める上で効果的である。

しかし、開発者が実際に実装する際の「勘所」や「行間」を読み解くと、以下の4つの論点が浮かび上がった。これらを仕様書で明確化することで、実装の曖昧さをなくし、開発をさらに加速できると考える。

---

### 論点1：コアロジックの型定義とDDLの同期問題

- **現状**: 仕様書では、API層がDBから取得した`user_accounts`の情報を`Account`型に変換し、コアロジック(`FAM`)に渡すことになっている。また、最終的なJSON出力には`sort_num`や`is_kpi`といったDDL由来の豊富な情報が含まれることを期待している。
- **課題**: コアロジック(`FAM`)が、これらの豊富な情報を受け取るための内部的な型定義（`@server/src/model/types.ts`内の`Account`型）が、現在のDDLと同期しているかが不明確である。`FAM`が`sort_num`を知らなければ、`getTable()`で返す`rows`オブジェクトに含めることができない。
- **提言**: **`Account`型定義を、`user_accounts`テーブルの全カラム（`sort_num`, `is_kpi`等）を保持できるように拡張する**ことを、仕様として明記すべきである。これにより、DBから取得した情報を欠落させることなくコアロジックに渡し、最終出力まで維持することが可能になる。

### 論点2：入力データにおける勘定科目IDの解決ロジック

- **現状**: 仕様書では、実績データ（`PREVS`）を生成する際に「JSON内の勘定科目名やコードを、`accountsMaster`を使って`accountId`に解決する必要がある」とされている。
- **課題**: この「解決ロジック」は、実装において最も曖昧さが生じやすい部分である。例えば、ユーザーがインポートしたデータに同名の勘定科目が存在した場合や、タイポがあった場合に、どの`user_accounts.id`にマッピングするべきか、エラーハンドリングをどうすべきか、といった具体的な戦略が不足している。
- **提言**: ID解決のルールをより厳密に定義すべきである。例えば、「まず`ua_code`で完全一致検索、次に`ua_name`で完全一致検索、見つからない場合はエラーとする」といった**フォールバック戦略とエラー処理方針を明確化する**必要がある。

### 論点3：DB側`rule_definition`のJSONBスキーマ定義

- **現状**: 仕様書は、API層がDBの`calculation_rules.rule_definition`（JSONB型）を、コアロジックが要求する`RuleInput`や`CFI`型に変換する責務を負う、と定めている。
- **課題**: この変換ロジックを実装する開発者にとって、変換元である`rule_definition`のJSONBがどのような構造を持っているのかが、この仕様書内では定義されていない（「スキーマはドキュメントで別途定義」と記載）。これは実装の着手を妨げる大きなブロッカーとなり得る。
- **提言**: このインターフェース仕様書に、**`rule_definition`のJSONBスキーマ定義そのものを含めるか、あるいは明確な参照先ドキュメントへのリンクを記載すべき**である。ソースとターゲット、両方のスキーマが揃って初めて、開発者は変換ロジックを実装できる。

### 論点4：API層における「データエンリッチメント」という隠れた責務

- **現状**: 提案した新しいJSONスキーマでは、`global_account`や`parent_user_account`といったネストされたオブジェクトを含み、UIにとって非常に有益である。
- **課題**: この構造を実現するためには、API層が`fam.getTable()`から返されたマトリクスデータをフラット化（アンピボット）する際に、単に値を並べ替えるだけでなく、**追加のデータ処理（エンリッチメント）** を行う必要がある。具体的には、`rows`に含まれる`parent_ga_id`や`parent_ua_id`をキーにして、再度アカウントリストから親勘定の情報を検索し、ネストされたオブジェクトを能動的に構築しなければならない。この責務が仕様書では暗黙的になっている。
- **提言**: API層の責務として、「`getTable()`の結果をアンピボットする」ことに加え、「**親勘定の情報を再検索し、`global_account`および`parent_user_account`オブジェクトを構築して、最終的なJSONを生成する**」というエンリッチメント処理の存在を明確に記述すべきである。
